<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Qizhou Deng -  Researching AI in Games, PCG, and Player Modeling.">
    <title>Qizhou Deng</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Palette: Deep Space & Neon Research */
            --bg-deep: #0a0a0f;
            --bg-surface: #13131a;
            --bg-glass: rgba(19, 19, 26, 0.7);

            --text-main: #e0e0e0;
            --text-muted: #9494a8;

            --accent-primary: #ff3366; /* Electric Coral */
            --accent-secondary: #00f2ea; /* Cyan for research/code vibes */

            --border: rgba(255, 255, 255, 0.08);
            --shadow-card: 0 10px 30px -10px rgba(0,0,0,0.5);
            --glow: 0 0 20px rgba(255, 51, 102, 0.15);
        }

        /* RESET & BASE */
        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            background-color: var(--bg-deep);
            color: var(--text-main);
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            background-image:
                    radial-gradient(circle at 15% 15%, rgba(255, 51, 102, 0.04) 0%, transparent 40%),
                    radial-gradient(circle at 85% 85%, rgba(0, 242, 234, 0.04) 0%, transparent 40%);
            background-attachment: fixed;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* TYPOGRAPHY */
        h1, h2, h3, h4 { color: #fff; letter-spacing: -0.02em; }
        h1 { font-weight: 800; font-size: 3.5rem; line-height: 1.1; margin-bottom: 0.5rem; }
        h2 { font-size: 1.8rem; font-weight: 700; margin-bottom: 1rem; }
        h3 { font-size: 1.5rem; font-weight: 600; margin-bottom: 0.75rem; }
        h4 { font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem; }
        p { color: var(--text-muted); font-size: 1.05rem; margin-bottom: 1.5rem; max-width: 65ch; }

        .mono { font-family: 'JetBrains Mono', monospace; font-size: 0.9em; }
        a { color: var(--text-main); text-decoration: none; transition: 0.2s; border-bottom: 1px solid var(--border); cursor: pointer; }
        a:hover { color: var(--accent-primary); border-color: var(--accent-primary); }

        /* LAYOUT UTILS */
        .container { max-width: 1100px; margin: 0 auto; padding: 0 2rem; }
        section { margin: 8rem 0; }

        /* HEADER */
        header {
            padding: 8rem 0 4rem;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(to bottom, rgba(10,10,15,0), var(--bg-deep));
        }
        .intro-tags {
            display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 1.5rem;
            font-family: 'JetBrains Mono', monospace; color: var(--accent-secondary);
        }

        /* PROJECTS (The Core) */
        .project-card {
            display: grid;
            grid-template-columns: 1.2fr 1fr; /* Image wider than text */
            gap: 3rem;
            margin-bottom: 6rem;
            align-items: center;
        }

        /* Alternating layout for variety */
        .project-card:nth-child(even) { grid-template-columns: 1fr 1.2fr; }
        .project-card:nth-child(even) .media-frame { order: 2; }

        .media-frame {
            position: relative;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 16/9;
            box-shadow: var(--shadow-card);
            border: 1px solid var(--border);
            transition: transform 0.3s ease;
        }
        .media-frame:hover { transform: translateY(-5px); border-color: var(--accent-secondary); }

        iframe { width: 100%; height: 100%; border: none; }

        .project-meta h3 { font-size: 2rem; margin-bottom: 0.5rem; }
        .project-sub { color: var(--accent-primary); font-weight: 600; margin-bottom: 1rem; display: block; }

        .tech-stack { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1.5rem; }
        .tech-pill {
            background: rgba(255,255,255,0.05);
            border: 1px solid var(--border);
            padding: 0.3rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            color: var(--text-main);
        }

        .actions { display: flex; gap: 1.5rem; font-weight: 600; }
        .btn-link {
            display: inline-flex; align-items: center; gap: 0.5rem;
            border-bottom: 2px solid var(--accent-secondary);
            padding-bottom: 2px;
            cursor: pointer;
        }
        .btn-link:hover { color: var(--accent-secondary); }

        /* PUBLICATIONS / SKILLS GRID */
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 4rem; }

        .pub-item {
            margin-bottom: 1.5rem; padding-left: 1rem;
            border-left: 2px solid var(--border); transition: 0.2s;
        }
        .pub-item:hover { border-left-color: var(--accent-primary); }
        .pub-title { color: #fff; font-weight: 600; display: block; }
        .pub-venue { font-style: italic; color: var(--accent-secondary); font-size: 0.9rem; }

        .skill-list { list-style: none; display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.5rem; }
        .skill-list li::before { content: "▹"; color: var(--accent-primary); margin-right: 0.5rem; }

        /* FOOTER */
        footer {
            margin-top: auto;
            text-align: center; padding: 4rem 0;
            border-top: 1px solid var(--border);
            color: var(--text-muted); font-size: 0.9rem;
        }

        /* BREAKDOWN VIEW STYLES */
        .article-content {
            margin-top: 4rem;
            max-width: 800px;
        }

        .article-content h2 {
            margin-top: 3rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .article-content h3 {
            margin-top: 2rem;
            color: var(--text-main);
        }

        .article-content ul {
            margin-bottom: 1.5rem;
            margin-left: 1.5rem;
            color: var(--text-muted);
        }

        .article-content li {
            margin-bottom: 0.5rem;
        }

        /* CODE BLOCK STYLES */
        pre {
            background: #0d0d12;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.2rem;
            overflow-x: auto;
            margin: 1.5rem 0;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }

        code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: #dcdcdc;
            line-height: 1.5;
        }

        /* Helper for the SPA Toggle */
        .hidden { display: none !important; }

        /* RESPONSIVE */
        @media (max-width: 900px) {
            h1 { font-size: 2.5rem; }
            .project-card, .project-card:nth-child(even) {
                grid-template-columns: 1fr; gap: 1.5rem;
            }
            .media-frame { order: 0 !important; } /* Image always top on mobile */
            .grid-2 { grid-template-columns: 1fr; gap: 2rem; }
        }
    </style>
</head>
<body>

<!-- HOME VIEW WRAPPER -->
<div id="home-view">

    <header>
        <div class="container">
            <h1>Qizhou Deng</h1>
            <p>
                Interested in •<strong>Game Development</strong> <strong>•AI in Games </strong>•<strong> Player Modeling </strong>•<strong> Procedural Content Generation </strong>• <strong>Systems Programming</strong>
            </p>
            <div class="intro-tags">
                <span>> AI_in_Games</span>
                <span>> C++</span>
                <span>> Unity</span>
                <span>> PCG</span>
            </div>
        </div>
    </header>

    <div class="container">

        <section id="work">
            <h2 style="border-bottom: 1px solid var(--border); padding-bottom: 1rem; margin-bottom: 3rem;">Selected Projects</h2>

            <article class="project-card">
                <div class="media-frame">
                    <img src="pommerman.png"
                         alt="Pommerman gameplay"
                         style="width:100%; height:100%; object-fit:cover; object-position:center top;">
                </div>
                <div class="project-meta">
                    <h3>Improved MCTS Agent in Pommerman</h3>
                    <span class="project-sub">Java AI Framework Implementation</span>
                    <p>
                        An enhanced AI agent developed for the multi-player game Pommerman. This project optimizes Monte Carlo Tree Search (MCTS) by integrating &alpha;-AMAF and RAVE algorithms to improve decision-making efficiency. It features custom heuristics for partial observability and demonstrates a 5% win-rate increase over standard benchmark agents.
                    </p>
                    <div class="tech-stack mono">
                        <span class="tech-pill">Java</span>
                        <span class="tech-pill">MCTS / AMAF / RAVE</span>
                        <span class="tech-pill">Heuristic Search</span>
                    </div>
                    <div class="actions">
                        <a href="Pommerman.pdf" target="_blank" class="btn-link">Tech Breakdown</a>
                        <a href="https://github.com/QizhouD/java-pommerman/tree/master/ImprovedMCTS" target="_blank" class="btn-link">View GitHub</a>
                    </div>
                </div>
            </article>

            <article class="project-card">
                <div class="media-frame">
                    <iframe frameborder="0" src="https://itch.io/embed/4102404" width="552" height="167"><a href="https://masterjim.itch.io/super-platformer">Super-Platformer by masterjim</a></iframe>                </div>
                <div class="project-meta">
                    <h3>3D Platformer Systems</h3>
                    <span class="project-sub">Real Time Platformer Game</span>
                    <p>
                        A scalable game architecture featuring a modular State Machine for character behavior and Strategy Pattern-based Enemy AI. Implements a fully decoupled event-driven input system and ScriptableObject architecture for robust maintainability and testability.
                    </p>
                    <div class="tech-stack mono">
                        <span class="tech-pill">Unity 3D</span>
                        <span class="tech-pill">C#</span>
                        <span class="tech-pill">State Pattern</span>
                        <span class="tech-pill">ScriptableObjects</span>
                    </div>
                    <div class="actions">
                        <!-- Update links as needed -->
                        <a onclick="showPlatformer()" class="btn-link">Tech Breakdown</a>
                        <a href="https://github.com/QizhouD/Super-Platformer-3D" target="_blank" class="btn-link">View GitHub</a>
                    </div>
                </div>
            </article>

            <article class="project-card">
                <div class="media-frame">
                    <iframe  src="https://www.youtube.com/embed/WgniXyY80Is?si=HhnHrWssUFyCjc2Z" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                </div>
                <div class="project-meta">
                    <h3>Dwarf V.S Mushroom</h3>
                    <span class="project-sub">Custom C++ Game </span>
                    <p>
                        A 2D action-platformer built from scratch to demonstrate low-level systems mastery. Features a custom Entity-Component System (ECS), memory pooling for particle effects, and a hand-written AABB physics solver.
                    </p>
                    <div class="tech-stack mono">
                        <span class="tech-pill">C++</span>
                        <span class="tech-pill">SFML</span>
                        <span class="tech-pill">Data-Oriented Design</span>
                    </div>
                    <div class="actions">
                        <!-- UPDATED LINK: Calls the JS function to switch views -->
                        <a onclick="showDwarf()" class="btn-link">Tech Breakdown</a>
                        <a href="https://github.com/QizhouD/2D-action-game" target="_blank" class="btn-link">View GitHub</a>
                    </div>
                </div>
            </article>

            <article class="project-card">
                <div class="media-frame" style="position: relative; background:#000;">
                    <canvas id="gameCanvas" style="width:100%; height:100%; object-fit: contain;"></canvas>
                    <div class="game-overlay">
                        WASD to Move • R to Regen • Click to Teleport
                    </div>
                </div>
                <div class="project-meta">
                    <h3>2D Procedural Content Generation</h3>
                    <span class="project-sub">Live JavaScript Simulation</span>
                    <p>
                        An interactive demo of procedural cave generation using <strong>Cellular Automata</strong>  and autonomous agent pathfinding using the <strong>A* algorithm</strong>.
                        The "Enemy" (Red) calculates the shortest path to the "Player" (Green) in real-time.
                    </p>
                    <div class="tech-stack mono">
                        <span class="tech-pill">JavaScript</span>
                        <span class="tech-pill">HTML5 Canvas</span>
                        <span class="tech-pill">Cellular Automata</span>
                        <span class="tech-pill">A* Pathfinding</span>
                    </div>
                    <div class="actions">
                        <a href="#" class="btn-link" onclick="initGame(); return false;">Regenerate Map</a>
                        <a href="#" class="btn-link btn-secondary">View Source</a>
                    </div>
                </div>
            </article>

        </section>

        <section>
            <div class="grid-2">

                <div>
                    <h2>Publications & Talks</h2>
                    <!-- Placeholder content preserved -->
                </div>

                <div>
                    <h2>Technical Proficiency</h2>
                    <h4 class="mono" style="color:var(--text-muted); margin: 1.5rem 0 0.5rem;">Languages</h4>
                    <ul class="skill-list mono">
                        <li>C++ (11/14/17)</li>
                        <li>C# / .NET</li>
                        <li>Python (PyTorch)</li>
                        <li>GLSL / HLSL</li>
                    </ul>

                    <h4 class="mono" style="color:var(--text-muted); margin: 1.5rem 0 0.5rem;">Tools & Frameworks</h4>
                    <ul class="skill-list mono">
                        <li>Unity 3D / Sentis</li>
                        <li>Unreal Engine 5</li>
                        <li>SDL2 / SFML</li>
                        <li>Git / Perforce</li>
                    </ul>
                </div>

            </div>
        </section>

    </div>
</div>
<!-- END HOME VIEW -->

<!-- PLATFORMER BREAKDOWN VIEW -->
<div id="platformer-view" class="hidden">

    <header style="padding: 4rem 0;">
        <div class="container">
            <a onclick="showHome()" class="btn-link" style="margin-bottom: 2rem; border: none; font-size: 0.9rem;">← Back to Projects</a>
            <h1>3D Platformer Systems</h1>
            <p class="mono" style="color: var(--accent-secondary);">Technical Breakdown & Design Document</p>
        </div>
    </header>

    <div class="container article-content">

        <h2>Summary</h2>
        <p>This portfolio details the core technical architecture of this game project, emphasizing the use of software engineering principles and design patterns. The project demonstrates State Machine design, Strategy Pattern implementation, and decoupled event-driven architecture (Event Channels, ScriptableObject Input).</p>
        <p>The key focus areas are:</p>
        <ol>
            <li>Modular State Management: A reusable, interface-driven State Machine System governs all complex character and enemy behaviors, ensuring clean, debuggable logic.</li>
            <li>Decoupled Input/UI: The Input System and Health System are fully decoupled from their consumer components (Player, UI) using the ScriptableObject Event Channel pattern, maximizing testability and flexibility.</li>
            <li>Configurable AI: The Enemy AI integrates a powerful Cone Detection Strategy using the Strategy Pattern, featuring an anti-flickering cooldown system for robust transitions.</li>
        </ol>
        <p>The resulting architecture is highly scalable and maintainable, ready for production use and complex feature expansion.</p>

        <h2>1. Architecture &amp; Design Philosophy</h2>
        <p>My primary goal was to create a highly decoupled and scalable system. This was achieved through the systematic application of industry-standard design patterns, significantly improving the maintainability and testability of complex features.</p>
        <ul>
            <li>State Machine Pattern (FSM): Used extensively for both the Player Controller and the Enemy AI System to encapsulate behaviors, making logic transitions explicit and easy to debug.</li>
            <li>Strategy Pattern: Implemented in the Detection System (e.g., ConeDetectionStrategy) and the Spawn System (LinearSpawnPointStrategy, RandomSpawnPointStrategy) to allow swapping core logic at runtime without modifying the main component.</li>
            <li>Event Channel / ScriptableObject Events: The Input System and the Health System are fully decoupled from the UI using this pattern. For instance, the Health component broadcasts a health percentage via a FloatEventChannel, which the HealthBar listens to, eliminating direct references.</li>
        </ul>

        <h2>2. Player Controller &amp; Advanced Movement</h2>
        <p>The PlayerController is the central hub, utilizing a state machine to manage complex interactions like variable-height jumping, dashing, and melee attacks.</p>
        <p><strong>Key Technical Demonstrations</strong></p>
        <ul>
            <li>Physics-Based Movement: Utilizes the Rigidbody component for smooth, physics-correct movement. Speed is applied and dampened using SmoothDamp to achieve natural-feeling acceleration (Smooth Time: 0.2s).</li>
            <li>Variable Jump Implementation: Achieves variable jump height by linking the upward velocity to a timer (Jump Duration: 0.5s). Releasing the jump input early stops the timer, immediately applying a high Gravity Multiplier (3x) for a fast, snappy fall.</li>
            <li>State Management: The player's actions (Locomotion, Jump, Dash, Attack) are managed by dedicated Player States. This prevents illegal actions (e.g., attacking while dashing) and centralizes action logic.</li>
        </ul>

        <style>
            .tech-table {
                width: 100%;
                border-collapse: collapse;
                margin: 2rem 0;
                font-size: 0.95rem;
                background-color: #fff;
                border-radius: 8px;
                overflow: hidden;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            }
            .tech-table th {
                background-color: #2c3e50;
                color: white;
                font-weight: 600;
                padding: 1rem;
                text-align: left;
            }
            .tech-table td {
                padding: 1rem;
                border-top: 1px solid #ecf0f1;
                vertical-align: top;
                color: #222;
            }
            .tech-table tbody tr:nth-child(even) {
                background-color: #f8f9fa;
            }
            .tech-table tbody tr:hover {
                background-color: #e8f4f8;
                transition: background-color 0.2s ease;
            }
            @media (max-width: 768px) {
                .tech-table {
                    display: block;
                    overflow-x: auto;
                }
                .tech-table th, .tech-table td {
                    white-space: nowrap;
                }
            }
        </style>

        <table class="tech-table">
            <thead>
            <tr>
                <th>Ability</th>
                <th>Mechanism</th>
                <th>Demonstrates</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Dash</td>
                <td>Force Multiplier (10x) applied for 1s, followed by a 2s cooldown.</td>
                <td>Time-based ability management &amp; physics manipulation.</td>
            </tr>
            <tr>
                <td>Double Jump</td>
                <td>Controlled by the hasDoubleJump flag, reset only when the GroundChecker component confirms the player is grounded.</td>
                <td>Precise physics state tracking.</td>
            </tr>
            <tr>
                <td>Melee Attack</td>
                <td>Uses a sphere-cast (Attack Distance: 1 unit) to detect targets, demonstrating proficiency with Unity's non-allocating physics queries.</td>
                <td>Physics query implementation &amp; cooldown management.</td>
            </tr>
            </tbody>
        </table>

        <h2>3. Free Look Camera System</h2>
        <p>The CameraManager uses Cinemachine's FreeLook camera, demonstrating robust input handling and responsiveness.</p>
        <p><strong>Key Features</strong></p>
        <ul>
            <li>Input Handling: Supports both mouse (RMB activated, cursor locked) and gamepad input separately, ensuring a smooth transition between control schemes.</li>
            <li>Anti-Jump System: Camera movement is locked for one frame when RMB is pressed to prevent sudden jumps from residual mouse movement, ensuring a professional feel.</li>
            <li>Sensitivity: Configurable Speed Multiplier for player-adjustable camera sensitivity.</li>
        </ul>

        <h2>4. In-Depth System Analysis: Modular State Machine System</h2>
        <p><strong>Overview</strong><br>The State Machine System provides a flexible, reusable framework for managing entity behavior, applied consistently to both the Player Controller and the Enemy AI System. It enforces the State Pattern to isolate specific behaviors, making state transitions explicit and logic predictable.</p>
        <p><strong>Architecture and Core Components</strong><br>The system is built upon a minimal set of interfaces, enforcing a clear contract for all behaviors and transitions.</p>
        <ul>
            <li>IState Interface: Defines the fundamental lifecycle of any behavior node.<br>• OnEnter(): Initialization logic when the state becomes active (e.g., set animation flag).<br>• Update(): Frame-by-frame logic (e.g., timer ticking, input checking).<br>• FixedUpdate(): Physics-frame logic (e.g., applying velocity, moving platforms).<br>• OnExit(): Cleanup logic before transitioning out (e.g., stop effects, reset flags).</li>
            <li>IPredicate Interface: A simple conditional check that returns bool. This separates the transition condition from the state logic.<br>• Evaluate(): Returns true if the condition for transition is met.</li>
            <li>ITransition Structure: Links two components: the To (Target State) and the Condition (The IPredicate instance).</li>
        </ul>

        <p><strong>The Transition Flow</strong><br>All transitions follow a strictly defined, three-step evaluation process within the State Machine's main Update loop:</p>
        <ol>
            <li>Any Transitions: Evaluate global transitions that can occur from any state (e.g., the Health component registers a IsDead predicate, immediately transitioning to the Death State).</li>
            <li>Current State Transitions: Evaluate the specific outgoing transitions defined for the currently active state (e.g., from LocomotionState → JumpState when JumpInputPressed predicate is met).</li>
            <li>State Change Execution: If a transition's condition is met, the flow executes: OnExit() of the old state → OnEnter() of the new state → The current_state reference is switched.</li>
        </ol>

        <p><strong>Player State Example: Locomotion to Jump</strong></p>
        <table class="tech-table">
            <thead>
            <tr>
                <th>Component</th>
                <th>State A</th>
                <th>Transition</th>
                <th>State B</th>
                <th>Predicate</th>
                <th>Condition</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Player</td>
                <td>LocomotionState</td>
                <td>→</td>
                <td>JumpState</td>
                <td>IsRunning&lt;JumpTimer&gt;</td>
                <td>The player is grounded AND the jump input is pressed.</td>
            </tr>
            <tr>
                <td>Player</td>
                <td>JumpState</td>
                <td>→</td>
                <td>LocomotionState</td>
                <td>IsGrounded</td>
                <td>The player's GroundChecker component returns true.</td>
            </tr>
            </tbody>
        </table>

        <h2>5. Spawn System</h2>
        <p><strong>Architecture</strong><br>The spawning system employs the Factory and Strategy patterns for flexibility.</p>
        <ul>
            <li>IEntityFactory&lt;T&gt;: Responsible for creating the entity instance.</li>
            <li>ISpawnPointStrategy: Determines where the entity is spawned.</li>
            <li>LinearSpawnPointStrategy: Cycles sequentially through points.</li>
            <li>RandomSpawnPointStrategy: Randomly selects unused points before reshuffling.</li>
        </ul>
        <p><strong>Collectible Spawning</strong><br>The CollectibleSpawnManager uses a countdown timer (Spawn Interval) to spawn items only until all configured spawn points have been used (Auto-Stop), demonstrating efficient resource management for level design.</p>

        <h2>6. Platform Types</h2>
        <p>Level interactivity is provided by several reusable, configurable platform components.</p>
        <table class="tech-table">
            <thead>
            <tr>
                <th>Platform Type</th>
                <th>Mechanism</th>
                <th>Technical Focus</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Timed Platform</td>
                <td>Toggles all child GameObjects on/off based on Time to Toggle Platform (2s).</td>
                <td>Time accumulation and object hierarchy manipulation.</td>
            </tr>
            <tr>
                <td>Vanishing Platform</td>
                <td>Detects Player tag collision, triggers an Animator for a smooth fade over Disappear Time, with an optional Can Reset delay.</td>
                <td>Collision handling and configurable reset logic.</td>
            </tr>
            <tr>
                <td>Horizontal/Vertical Platform</td>
                <td>Uses MoveTowards between two defined points/heights, incorporating a Time Delay wait period at each end.</td>
                <td>Vector mathematics (MoveTowards) and path configuration.</td>
            </tr>
            </tbody>
        </table>

        <h2>7. Enemy AI System</h2>
        <p>The enemy utilizes the State Machine (Wander, Chase, Attack) driven by the Detection System.</p>
        <p><strong>Enemy States</strong></p>
        <ul>
            <li>EnemyWanderState: Patrols using the NavMeshAgent to pathfind to random points within the Wander Radius (10 units).</li>
            <li>EnemyChaseState: Continuously updates the NavMeshAgent destination to the player's position, triggered by detection.</li>
            <li>EnemyAttackState: Executes combat logic while respecting the Time Between Attacks cooldown.</li>
        </ul>

        <h2>8. In-Depth System Analysis: Detection System</h2>
        <p><strong>Overview</strong><br>The Detection System is designed using the Strategy Pattern (IDetectionStrategy), allowing the PlayerDetector component to swap out its detection algorithm at runtime. This makes the Enemy AI highly flexible and extensible.</p>
        <p><strong>Cone Detection Strategy Implementation</strong><br>The ConeDetectionStrategy is the default behavior, designed for realistic, yet performant, line-of-sight tracking.</p>

        <p><strong>Parameters</strong></p>
        <table class="tech-table">
            <thead>
            <tr>
                <th>Parameter</th>
                <th>Value</th>
                <th>Purpose</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Detection Angle</td>
                <td>60°</td>
                <td>The total width of the vision cone.</td>
            </tr>
            <tr>
                <td>Detection Radius</td>
                <td>10 units</td>
                <td>The maximum effective range of the cone.</td>
            </tr>
            <tr>
                <td>Inner Detection Radius</td>
                <td>5 units</td>
                <td>A guaranteed detection sphere for close proximity.</td>
            </tr>
            <tr>
                <td>Detection Cooldown</td>
                <td>1 second</td>
                <td>Prevents state flickering near the radius edge.</td>
            </tr>
            </tbody>
        </table>

        <p><strong>Detection Logic (CanDetectPlayer())</strong><br>The detection check utilizes vector math and distance comparisons:</p>
        <ol>
            <li>Calculate Direction and Angle: Determine the normalized direction vector from the enemy to the player. The angle θ between the enemy's forward vector (Forward) and the player direction (Dir) is calculated: θ = arccos(Forward • Dir).</li>
            <li>Cone Check: Player is detected if the distance d &lt; 10 AND the angle θ &lt; 30° (half of the 60° angle).</li>
            <li>Inner Radius Check: Player is detected if the distance d &lt;= 5 (regardless of angle), covering blind spots or close-range detection.</li>
            <li>Cooldown Application: If detection occurs, a CountdownTimer is started. The CanDetectPlayer() method returns true for the entire 1-second duration of the timer. This prevents the Enemy AI from rapidly transitioning between Chase and Wander states, ensuring smooth and stable gameplay.</li>
        </ol>

        <p><strong>Extensibility (Strategy Pattern)</strong><br>To implement a new detection type, a developer only needs to:</p>
        <ol>
            <li>Create a new class implementing IDetectionStrategy.</li>
            <li>Call detector.SetDetectionStrategy(new NewDetectionStrategy()) at runtime.</li>
        </ol>
        <p>This adheres to the Open/Closed Principle, allowing for new features without modifying existing, tested code.</p>

        <h2>9. Input System</h2>
        <p><strong>Design Choice</strong><br>The system uses a ScriptableObject-based InputReader with Unity's new Input System.</p>
        <p><strong>Benefit</strong><br>This completely separates input logic from the player character, making the system:</p>
        <ul>
            <li>Device-Agnostic: Handles keyboard, mouse, and gamepad input seamlessly.</li>
            <li>Flexible: Easy rebinding and centralized control.</li>
            <li>Event-Driven: Input phase (Started, Canceled, Performed) → InputReader → Invokes a corresponding UnityEvent (e.g., Jump(bool performed)).</li>
        </ul>

        <h2>10. Health System</h2>
        <p><strong>Health Component</strong><br>Manages health and uses the Event Channel pattern for decoupled UI updates. When TakeDamage(int) is called, the component calculates the health percentage (0-1) and broadcasts it on a FloatEventChannel.</p>
        <p><strong>Health Bar Component</strong><br>This component subscribes to the FloatEventChannel and updates the UI slider and the color gradient (Green → Red) without holding a direct reference to the Player's Health component.</p>

        <h2>11. Summary</h2>
        <table class="tech-table">
            <thead>
            <tr>
                <th>System</th>
                <th>Practice</th>
                <th>Rationale</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>State Machines</td>
                <td>Separate state logic from entity logic; use predicates for transitions.</td>
                <td>Ensures single responsibility and ease of debugging.</td>
            </tr>
            <tr>
                <td>Input</td>
                <td>Use a single InputReader ScriptableObject; always unsubscribe from events.</td>
                <td>Centralized control and prevention of memory leaks.</td>
            </tr>
            <tr>
                <td>Timers</td>
                <td>Tick timers in Update, not FixedUpdate; use CountdownTimer.</td>
                <td>Ensures time is tracked independently of physics frames.</td>
            </tr>
            <tr>
                <td>Detection</td>
                <td>Tune values with Gizmo visualization; use cooldowns.</td>
                <td>Prevents state flickering and allows visual configuration.</td>
            </tr>
            <tr>
                <td>Spawning</td>
                <td>Separate data (ScriptableObject) from logic (MonoBehaviour).</td>
                <td>Increases modularity and simplifies asset management.</td>
            </tr>
            </tbody>
        </table>

        <br><br>
        <p class="mono" style="color: var(--text-secondary); text-align: center;">
            Built in Unity
        </p>

    </div>
</div>
<!-- END PLATFORMER VIEW -->

<!-- DWARF BREAKDOWN VIEW WRAPPER (Hidden by default) -->
<div id="dwarf-view" class="hidden">

    <header style="padding: 4rem 0;">
        <div class="container">
            <a onclick="showHome()" class="btn-link" style="margin-bottom: 2rem; border: none; font-size: 0.9rem;">← Back to Projects</a>
            <h1>Dwarf V.S Mushroom</h1>
            <p class="mono" style="color: var(--accent-secondary);">Technical Breakdown & Design Document</p>
        </div>
    </header>

    <div class="container article-content">

        <h2>Overview</h2>
        <p>This project is a 2D action game built with SFML that I architected around a lightweight Entity–Component–System (ECS) core. It features a text-driven level loader, real-time spawning, collision and gameplay systems, a letterboxed render pipeline, and a minimal UI layer for HUD and menus. The codebase demonstrates applied software engineering patterns (Observer, Service Locator), data-driven world construction, and experimentation with multiple ECS storage strategies (big-array, archetypes, packed-array) for performance and maintainability.</p>

        <h2>Tech Stack and Key Libraries</h2>
        <ul>
            <li><strong>SFML 2.x</strong> for windowing, graphics, input, timing, and basic audio plumbing</li>
            <li><strong>C++17 STL</strong> (<code>&lt;memory&gt;</code>, <code>&lt;vector&gt;</code>, <code>&lt;unordered_map&gt;</code>, <code>&lt;functional&gt;</code>, <code>&lt;random&gt;</code>, etc.)</li>
            <li><strong>Custom ECS utilities:</strong> <code>Bitmask</code>, <code>PackedArray</code>, system interfaces, and an <code>Observer</code> implementation</li>
        </ul>

        <h2>High-Level Architecture</h2>
        <p><strong>Game loop entry:</strong> <code>main.cpp</code> initializes <code>Game</code>, loads a textual level, and runs an adaptive fixed-target loop (nominally 60 FPS):</p>
        <pre><code>// main.cpp
while (!game.getWindow()->isWindowDone()) {
    adaptiveLoop(game, lastTime, 0.016f);
}</code></pre>

        <p><strong>Core controller:</strong> <code>Game</code> orchestrates lifecycle (<code>init</code>, <code>handleInput</code>, <code>update</code>, <code>render</code>), state transitions, level management, ECS systems, and statistics.</p>
        <p><strong>Rendering/UI:</strong> <code>Window</code> wraps <code>sf::RenderWindow</code>, a letterboxed <code>sf::View</code>, GUI font assets, and HUD/menu drawing.</p>
        <p><strong>World building:</strong> <code>Board</code> manages tiles; level parsing maps ASCII to tiles/entities, which are created via data helpers like <code>buildEntityAt</code>.</p>
        <p><strong>Systems:</strong> Input, Movement, Collider, Gameplay, TTL, Graphics, and Debug systems run per-entity, guarded by <code>validate</code> filters.</p>

        <h2>ECS Design and Storage Strategies</h2>
        <p><code>Game</code> supports switching ECS backends via <code>ECSType</code>:</p>
        <ul>
            <li><code>ECSType::BIG_ARRAY</code>: Iterate all entities for each system (<code>Game::bigArray</code>). Simple, cache-friendly when components are dense.</li>
            <li><code>ECSType::ARCHETYPES</code>: Groups entities by component bitmask (<code>Archetype</code>) for faster system filtering.</li>
            <li><code>ECSType::PACKED_ARRAY</code>: Uses <code>PackedArray&lt;Entity&gt;</code> for stable, compact storage and fast removal.</li>
        </ul>

        <p>Key excerpts:</p>
        <pre><code>// Game.h
enum class ECSType { BIG_ARRAY, ARCHETYPES, PACKED_ARRAY };
struct Archetype {
    std::vector&lt;std::shared_ptr&lt;Entity&gt;&gt; entities;
    Bitmask componentMask;
};</code></pre>

        <pre><code>// Game.cpp
systems = { make&lt;InputSystem&gt;(), make&lt;MovementSystem&gt;(), make&lt;ColliderSystem&gt;(),
            make&lt;GameplaySystem&gt;(), make&lt;PrintDebugSystem&gt;(), make&lt;TTLSystem&gt;() };</code></pre>

        <p>This design lets me compare iteration and filtering tradeoffs across ECS layouts and lays groundwork for archetype-specific updates (<code>Game::updateArchetypes</code>) or packed, indirect indexing (<code>Game::updatePackedArray</code>).</p>

        <h2>Game Loop, Timing, and Frame Pacing</h2>
        <ul>
            <li><strong>Time source:</strong> <code>sf::Clock</code> in <code>Game</code> and <code>getElapsed()</code> queries in <code>main</code>.</li>
            <li><strong>Loop method:</strong> <code>adaptiveLoop(Game&, lastTime, updateTarget)</code> computes per-frame <code>elapsedSeconds</code>, runs <code>handleInput → update → render</code>, then sleeps the remainder to hit the target frame time, and computes instantaneous FPS.</li>
        </ul>

        <pre><code>float elapsedSeconds = current - lastTime;
if (elapsedSeconds < updateTarget) {
    sf::sleep(sf::seconds(updateTarget - elapsedSeconds));
}
float fps = 1.0f / elapsedSeconds;</code></pre>

        <p><code>Game::setFPS(int)</code> updates an on-screen counter; a <code>PrintDebugSystem</code> provides additional instrumentation.</p>

        <h2>Windowing, Views, and Letterboxing</h2>
        <p><code>Window</code> encapsulates creation of <code>sf::RenderWindow</code> in windowed or fullscreen modes. It uses a fixed logical <code>sf::View</code> sized to the game world (<code>logicalViewSize</code>), with a letterbox applied on resize to preserve aspect ratio.</p>

        <pre><code>static void applyLetterboxToView(sf::View& v, unsigned w, unsigned h) {
    float windowRatio = float(w)/h, viewRatio = v.getSize().x / v.getSize().y;
    // compute viewport {posX, posY, sizeX, sizeY}
}</code></pre>

        <ul>
            <li><strong>GUI assets:</strong> a global font, FPS text, pause text, health text/bar, and a simple menu (<code>Dwarf VS Mushrooms</code>) prompt.</li>
            <li><code>drawGUI(const Game&)</code> renders HUD elements (FPS, health, menu, result) over the game view.</li>
        </ul>

        <h2>Level Loading and World Construction</h2>
        <p><code>main.cpp</code> reads <code>levels/lvl0.txt</code> into <code>std::vector&lt;std::string&gt;</code>.</p>
        <p><code>Game::parseLevelLines</code> converts ASCII to world:</p>
        <ul>
            <li><code>'.'</code> → corridor tile (<code>img/floor.png</code>)</li>
            <li><code>'w'</code> → wall tile (<code>img/wall.png</code>)</li>
            <li><code>'x'</code> → place a log entity and floor tile</li>
            <li>Additional symbols map similarly (player spawn, enemies, pickups, etc.).</li>
        </ul>

        <pre><code>const int spriteWH = 50;
const float tileScale = 2.0f, itemScale = 1.0f;
// Center entities on tiles
ent->setPosition(col * spriteWH * tileScale + center, row * spriteWH * tileScale + center);</code></pre>
        <p>This makes level creation data-driven, reproducible, and trivially editable with a text editor.</p>

        <h2>Gameplay Systems and Mechanics</h2>
        <ul>
            <li><strong>Input:</strong> <code>InputHandler</code> and <code>InputSystem</code> translate SFML events and keyboard state into player commands (<code>Command</code> pattern).</li>
            <li><strong>Movement:</strong> <code>MovementSystem</code> integrates velocities into positions per <code>elapsed</code>.</li>
            <li><strong>Collisions:</strong> <code>ColliderSystem</code> resolves entity collisions and tile blocking, invoking type-specific callbacks via:</li>
        </ul>
        <pre><code>void Game::registerCollisionCallback(EntityType type, std::function&lt;void(Entity*)&gt; cb);</code></pre>
        <ul>
            <li><strong>TTL:</strong> <code>TTLSystem</code> expires temporary entities (e.g., projectiles, hit effects).</li>
            <li><strong>Rendering:</strong> <code>GraphicsSystem</code> draws all <code>GRAPHICS</code>-tagged components to the <code>Window</code>’s <code>gameView</code>.</li>
            <li><strong>Gameplay:</strong> <code>GameplaySystem</code> handles health, attacks, pickups, and scoring. The <code>Observer</code> is used to notify achievements and stat changes without tight coupling.</li>
        </ul>

        <h2>State Management and Flow</h2>
        <p><code>enum class GameState { Menu, Playing, Result };</code></p>
        <p>In Menu, the GUI displays a title and “Press Enter to Start”. <code>Enter</code> transitions to Playing (<code>Game::startGame()</code>).</p>
        <p>During play, the engine tracks:</p>
        <ul>
            <li><code>killCount</code>, <code>fireShotCount</code> via <code>incrementKills()</code> / <code>incrementFireShots()</code></li>
            <li><code>levelClock</code> to compute <code>levelFinishSeconds</code></li>
        </ul>
        <p>On level completion or player death, <code>triggerSettlement()</code> records the result and switches to <code>Result</code> for summary.</p>

        <h2>Software Engineering Patterns and Rationale</h2>
        <ul>
            <li><strong>Observer Pattern</strong> (<code>utils/Observer.h</code>): decouples gameplay events (e.g., kill, shot fired, level complete) from UI and achievement tracking.</li>
            <li><strong>Service Locator</strong> (<code>core/ServiceLocator.h</code>): provides access to <code>AudioManager</code> without injecting it through every system/constructor. For a larger codebase, I’d migrate to explicit dependency injection, but this keeps the sample concise.</li>
            <li><strong>Command Pattern</strong> (<code>core/Command.h</code>): encapsulates player actions, making input rebinds and AI control easy.</li>
        </ul>

        <h2>Performance and Complexity Considerations</h2>
        <ul>
            <li><strong>ECS variants</strong> allow exploring iteration complexity vs. memory layout:
                <ul>
                    <li><strong>Big-array:</strong> O(S×E) iteration; simplest to reason about; good when many systems touch most entities.</li>
                    <li><strong>Archetypes:</strong> filters reduce E per system; better cache locality when grouping by component masks.</li>
                    <li><strong>Packed arrays:</strong> reduce fragmentation and speed up removal; dense memory improves traversal.</li>
                </ul>
            </li>
            <li><strong>Rendering:</strong> letterboxed view prevents stretching and reduces overdraw outside the logical viewport.</li>
            <li><strong>Frame pacing:</strong> simple sleep-based limiter provides a stable 60 FPS target on typical Windows timers. Would upgrade to a fixed-step update accumulator under load and consider <code>timeBeginPeriod</code>/Waitable timers for precision.</li>
        </ul>

        <h2>Selected Code Pointers</h2>
        <ul>
            <li>Entry and loop: <code>SFML\main.cpp</code></li>
            <li>Game orchestration: <code>include\core\Game.h</code>, <code>source\core\Game.cpp</code></li>
            <li>Windowing/UI: <code>include\graphics\Window.h</code>, <code>source\graphics\Window.cpp</code></li>
            <li>Entities: <code>include\entities\Mushroom.h</code>, <code>include\entities\Player.h</code>, <code>include\entities\StaticEntities.h</code>, <code>include\entities\Fire.h</code></li>
            <li>Systems: <code>include\systems\Systems.h</code></li>
            <li>Utilities: <code>include\utils\PackedArray.h</code>, <code>include\utils\Observer.h</code></li>
        </ul>

        <h2>Project Highlight</h2>
        <ul>
            <li><strong>Engine architecture:</strong> clear separation of concerns (loop, ECS, rendering, UI) and the ability to swap ECS storage strategies to study performance.</li>
            <li><strong>Data-driven content:</strong> ASCII level files parsed into a tile/actor world with consistent scaling and positioning.</li>
            <li><strong>Practical patterns:</strong> Observer and Service Locator applied judiciously; command-based input; clean window/view management with letterboxing.</li>
            <li><strong>Production-minded considerations:</strong> frame pacing, GUI overlays, spawning control, collision callbacks by <code>EntityType</code>, and a structured game state machine.</li>
        </ul>

        <div style="margin-top: 4rem; text-align: center;">
            <a onclick="showHome()" class="btn-link" style="font-size: 1.2rem;">← Back to Projects</a>
        </div>
    </div>
</div>
<!-- END DWARF BREAKDOWN VIEW -->


<footer>
    <div class="container">
        <p style="margin-bottom: 0.5rem; color: #fff;">
            <strong>Qizhou Deng</strong> • qizhoudeng0@gmail.com
        </p>
        <div style="margin-bottom: 2rem;">
            <a href="#" style="margin: 0 10px;">LinkedIn</a>
            <a href="https://github.com/QizhouD" style="margin: 0 10px;">GitHub</a>
            <a href="#" style="margin: 0 10px;">Download CV</a>
        </div>
        <p class="mono" style="font-size: 0.75rem; opacity: 0.5;">
           HTML5/CSS3 and JavaScript .
        </p>
    </div>
</footer>

<script>
    // Simple SPA logic
    function hideAll() {
        document.getElementById('home-view').classList.add('hidden');
        document.getElementById('platformer-view').classList.add('hidden');
        document.getElementById('dwarf-view').classList.add('hidden');
    }

    function showPlatformer() {
        hideAll();
        document.getElementById('platformer-view').classList.remove('hidden');
        window.scrollTo(0,0);
    }

    function showDwarf() {
        hideAll();
        document.getElementById('dwarf-view').classList.remove('hidden');
        window.scrollTo(0,0);
    }

    function showHome() {
        hideAll();
        document.getElementById('home-view').classList.remove('hidden');
        window.scrollTo(0, document.getElementById('work').offsetTop);
    }
    /**
     * --- GAME LOGIC INTEGRATION ---
     */
    const TILE_SIZE = 20;
    const MAP_WIDTH = 50;
    const MAP_HEIGHT = 30;
    const SMOOTHING_ITERATIONS = 5;
    const FILL_PERCENT = 45;
    const ENEMY_SPEED_FACTOR = 5;

    // Colors
    const COLORS = {
        wall: '#334155',
        floor: '#0f172a',
        player: '#4ade80',
        enemy: '#f87171',
        path: 'rgba(96, 165, 250, 0.4)',
        grid: '#1e293b'
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game State
    let map = [];
    let player = { x: 1, y: 1 };
    let enemy = { x: 1, y: 1 };
    let path = [];
    let frameCount = 0;

    // Set internal resolution
    canvas.width = MAP_WIDTH * TILE_SIZE;
    canvas.height = MAP_HEIGHT * TILE_SIZE;

    // Input
    const keys = {};
    window.addEventListener('keydown', (e) => {
        // Prevent scrolling when using arrow keys or space
        if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].indexOf(e.code) > -1) {
            e.preventDefault();
        }
        keys[e.key.toLowerCase()] = true;
        if (e.key.toLowerCase() === 'r') initGame();
    });
    window.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

    // Mouse Teleport
    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        // Calculate scale factor because canvas is styled with CSS width 100%
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;

        const x = Math.floor(((e.clientX - rect.left) * scaleX) / TILE_SIZE);
        const y = Math.floor(((e.clientY - rect.top) * scaleY) / TILE_SIZE);

        if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT && map[x][y] === 0) {
            player.x = x;
            player.y = y;
            findPath();
            draw();
        }
    });

    function generateMap() {
        map = [];
        for (let x = 0; x < MAP_WIDTH; x++) {
            map[x] = [];
            for (let y = 0; y < MAP_HEIGHT; y++) {
                if (x === 0 || x === MAP_WIDTH - 1 || y === 0 || y === MAP_HEIGHT - 1) {
                    map[x][y] = 1;
                } else {
                    map[x][y] = (Math.random() * 100 < FILL_PERCENT) ? 1 : 0;
                }
            }
        }
        for (let i = 0; i < SMOOTHING_ITERATIONS; i++) {
            smoothMap();
        }
    }

    function smoothMap() {
        let newMap = [];
        for (let x = 0; x < MAP_WIDTH; x++) {
            newMap[x] = [];
            for (let y = 0; y < MAP_HEIGHT; y++) {
                let wallCount = getSurroundingWallCount(x, y);
                if (wallCount > 4) newMap[x][y] = 1;
                else if (wallCount < 4) newMap[x][y] = 0;
                else newMap[x][y] = map[x][y];
            }
        }
        map = newMap;
    }

    function getSurroundingWallCount(gridX, gridY) {
        let wallCount = 0;
        for (let neighborX = gridX - 1; neighborX <= gridX + 1; neighborX++) {
            for (let neighborY = gridY - 1; neighborY <= gridY + 1; neighborY++) {
                if (neighborX >= 0 && neighborX < MAP_WIDTH && neighborY >= 0 && neighborY < MAP_HEIGHT) {
                    if (neighborX !== gridX || neighborY !== gridY) {
                        wallCount += map[neighborX][neighborY];
                    }
                } else {
                    wallCount++;
                }
            }
        }
        return wallCount;
    }

    function findFreeSpot() {
        let attempts = 0;
        while (attempts < 1000) {
            let x = Math.floor(Math.random() * MAP_WIDTH);
            let y = Math.floor(Math.random() * MAP_HEIGHT);
            if (map[x][y] === 0) return { x, y };
            attempts++;
        }
        return { x: 1, y: 1 };
    }

    // --- A* Pathfinding ---
    class Node {
        constructor(x, y, isWall) {
            this.x = x; this.y = y; this.isWall = isWall;
            this.g = 0; this.h = 0; this.f = 0; this.parent = null;
        }
    }

    function findPath() {
        let openSet = [];
        let closedSet = [];
        let gridNodes = [];

        for(let x=0; x<MAP_WIDTH; x++){
            gridNodes[x] = [];
            for(let y=0; y<MAP_HEIGHT; y++){
                gridNodes[x][y] = new Node(x, y, map[x][y] === 1);
            }
        }

        let startNode = gridNodes[enemy.x][enemy.y];
        let targetNode = gridNodes[player.x][player.y];

        if(targetNode.isWall) return;

        openSet.push(startNode);

        while (openSet.length > 0) {
            let winner = 0;
            for (let i = 0; i < openSet.length; i++) {
                if (openSet[i].f < openSet[winner].f) winner = i;
            }
            let current = openSet[winner];

            if (current === targetNode) {
                path = [];
                let temp = current;
                while (temp.parent) {
                    path.push({x: temp.x, y: temp.y});
                    temp = temp.parent;
                }
                path.reverse();
                return;
            }

            openSet.splice(winner, 1);
            closedSet.push(current);

            let neighbors = getNeighbors(current, gridNodes);
            for (let neighbor of neighbors) {
                if (closedSet.includes(neighbor) || neighbor.isWall) continue;

                let tempG = current.g + 1;
                let newPath = false;

                if (openSet.includes(neighbor)) {
                    if (tempG < neighbor.g) {
                        neighbor.g = tempG;
                        newPath = true;
                    }
                } else {
                    neighbor.g = tempG;
                    newPath = true;
                    openSet.push(neighbor);
                }

                if (newPath) {
                    neighbor.h = Math.abs(neighbor.x - targetNode.x) + Math.abs(neighbor.y - targetNode.y);
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = current;
                }
            }
        }
        path = [];
    }

    function getNeighbors(node, gridNodes) {
        let neighbors = [];
        let dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (let dir of dirs) {
            let x = node.x + dir[0];
            let y = node.y + dir[1];
            if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
                neighbors.push(gridNodes[x][y]);
            }
        }
        return neighbors;
    }

    // --- Loop ---
    function update() {
        frameCount++;
        if (frameCount % 5 === 0) {
            let dx = 0; let dy = 0;
            if (keys['w'] || keys['arrowup']) dy = -1;
            if (keys['s'] || keys['arrowdown']) dy = 1;
            if (keys['a'] || keys['arrowleft']) dx = -1;
            if (keys['d'] || keys['arrowright']) dx = 1;

            if (dx !== 0 || dy !== 0) {
                let targetX = player.x + dx;
                let targetY = player.y + dy;
                if (targetX >= 0 && targetX < MAP_WIDTH && targetY >= 0 && targetY < MAP_HEIGHT && map[targetX][targetY] === 0) {
                    player.x = targetX;
                    player.y = targetY;
                    findPath();
                }
            }
        }

        if (frameCount % ENEMY_SPEED_FACTOR === 0) {
            if (path.length > 0) {
                enemy.x = path[0].x;
                enemy.y = path[0].y;
            }
            findPath();
        }
    }

    function draw() {
        ctx.fillStyle = COLORS.floor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let x = 0; x < MAP_WIDTH; x++) {
            for (let y = 0; y < MAP_HEIGHT; y++) {
                if (map[x][y] === 1) {
                    ctx.fillStyle = COLORS.wall;
                    ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                } else {
                    ctx.strokeStyle = COLORS.grid;
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        if (path.length > 0) {
            ctx.beginPath();
            ctx.moveTo(enemy.x * TILE_SIZE + TILE_SIZE/2, enemy.y * TILE_SIZE + TILE_SIZE/2);
            for (let p of path) {
                ctx.lineTo(p.x * TILE_SIZE + TILE_SIZE/2, p.y * TILE_SIZE + TILE_SIZE/2);
            }
            ctx.strokeStyle = COLORS.path;
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        drawEntity(player.x, player.y, COLORS.player);
        drawEntity(enemy.x, enemy.y, COLORS.enemy);
    }

    function drawEntity(gridX, gridY, color) {
        let x = gridX * TILE_SIZE;
        let y = gridY * TILE_SIZE;
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4, 4);
        ctx.fill();
    }

    function initGame() {
        generateMap();
        player = findFreeSpot();
        enemy = findFreeSpot();
        while(Math.abs(enemy.x - player.x) + Math.abs(enemy.y - player.y) < 5) enemy = findFreeSpot();
        findPath();
        frameCount = 0;
    }

    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // Start
    initGame();
    loop();
</script>

</body>
</html>
